// ********************* Generated by a tool *********************
/*
  pins_fastduino.hpp - Pin definition functions for Arduino adapted to work with Dwenguino v2.0
  Part of the Dwengo library

  Originally made by David A. Mellis,

  Copyright (c) 2007 David A. Mellis

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General
  Public License along with this library; if not, write to the
  Free Software Foundation, Inc., 59 Temple Place, Suite 330,
  Boston, MA  02111-1307  USA

  $Id: wiring.h 249 2007-02-03 16:52:51Z mellis $
*/

/*
  Modified on Dec 20 2014 by Jelle Roets from Dwengo vzw (www.dwengo.org)
    Pin definition for dwenguino v2.0

  TODO:
    - make arduino core ready for AT90USB646  (wiring_private.h: EXTERNAL_NUM_INTERRUPTS, WInterrupts.c: define interrupts, Wiring )
*/

#ifndef FH_PINS_FASTDUINO_H_
#define FH_PINS_FASTDUINO_H_



// Libraries control:
#define TONE_USE_TIMER2         // Use timer 2 for Tone, You can also choose to use timer 1 or 3
#define DISABLE_NEWPING_TIMER   // disable timer functionality of newpin library because they use same timer2 in CTC mode as tone function

#define NUM_DIGITAL_PINS  48
#define NUM_ANALOG_INPUTS 8

// No TX or RX led connected 
#define TX_RX_LED_INIT	//DDRD |= (1<<5), DDRB |= (1<<0)
#define TXLED0			//PORTD |= (1<<5)
#define TXLED1			//PORTD &= ~(1<<5)
#define RXLED0			//PORTB |= (1<<0)
#define RXLED1			//PORTB &= ~(1<<0)
    
static constexpr std::uint8_t RX = 0;
static constexpr std::uint8_t TX = 1;

static constexpr std::uint8_t SDA = 15;
static constexpr std::uint8_t SCL = 14;

// Map SPI port to 'new' pins 
static constexpr std::uint8_t SS   = 10;
static constexpr std::uint8_t MOSI = 2;
static constexpr std::uint8_t MISO = 12;
static constexpr std::uint8_t SCK  = 13;

// Mapping of analog pins as digital I/O
static constexpr std::uint8_t A0 = 24;
static constexpr std::uint8_t A1 = 25;
static constexpr std::uint8_t A2 = 26;
static constexpr std::uint8_t A3 = 27;
static constexpr std::uint8_t A4 = 28;
static constexpr std::uint8_t A5 = 29;
static constexpr std::uint8_t A6 = 30; 
static constexpr std::uint8_t A7 = 31;

static constexpr std::uint8_t BAND_GAP = 70; 
static constexpr std::uint8_t GROUND = 71; // = 31 - 8 + 48 (for more info see ino_mux at the end of this file)

// Dwengo functionality
// LEDs
#define LEDS_DIR DDRA
#define LEDS PORTA
static constexpr std::uint8_t LED0 = 32;
static constexpr std::uint8_t LED1 = 33;
static constexpr std::uint8_t LED2 = 34;
static constexpr std::uint8_t LED3 = 35;
static constexpr std::uint8_t LED4 = 36;
static constexpr std::uint8_t LED5 = 37;
static constexpr std::uint8_t LED6 = 38;
static constexpr std::uint8_t LED7 = 39;

// Buzzer
static constexpr std::uint8_t BUZZER = 46;

// Buttons
static constexpr std::uint8_t SW_C = 47;
static constexpr std::uint8_t SW_N = 16;
static constexpr std::uint8_t SW_E = 17;
static constexpr std::uint8_t SW_S = 18;
static constexpr std::uint8_t SW_W = 19;

// DC motor connector
static constexpr std::uint8_t MOTOR_1_0 = 44; // Motor PWM
static constexpr std::uint8_t MOTOR_1_1 = 43; // Motor direction
static constexpr std::uint8_t MOTOR_2_0 = 45; // Motor PWM
static constexpr std::uint8_t MOTOR_2_1 = 42; // Motor direction

// Servo motors
static constexpr std::uint8_t SERVO_1 = 40;
static constexpr std::uint8_t SERVO_2 = 41;

// Dwengo LCD
static constexpr std::uint8_t LCD_BL = 20;
static constexpr std::uint8_t LCD_E = 21;
static constexpr std::uint8_t LCD_RW = 22;
static constexpr std::uint8_t LCD_RS = 23;
static constexpr std::uint8_t LCD_D0 = 32;
static constexpr std::uint8_t LCD_D1 = 33;
static constexpr std::uint8_t LCD_D2 = 34;
static constexpr std::uint8_t LCD_D3 = 35;
static constexpr std::uint8_t LCD_D4 = 36;
static constexpr std::uint8_t LCD_D5 = 37;
static constexpr std::uint8_t LCD_D6 = 38;
static constexpr std::uint8_t LCD_D7 = 39;

// External interrupts
static constexpr std::uint8_t D0_INT= 2;   // INT2 on PD2 - D0
static constexpr std::uint8_t D1_INT= 3;   // INT3 on PD3 - D1
static constexpr std::uint8_t D14_INT = 0; // INT0 on PD0 - D14
static constexpr std::uint8_t D15_INT = 1; // INT1 on PD1 - D15
static constexpr std::uint8_t D16_INT = 7; // INT7 on PE7 - D16
static constexpr std::uint8_t D17_INT = 6; // INT6 on PE6 - D17
static constexpr std::uint8_t D18_INT = 5; // INT5 on PE5 - D18
static constexpr std::uint8_t D19_INT = 4; // INT4 on PE4 - D19

// PCINT 0-7 are on pins 6-13
#define digitalPinToPCICR(p)    ( (((p) >= 6) && ((p) <= 13)) ? (&PCICR) : ((std::uint8_t *)0) )
#define digitalPinToPCICRbit(p) 0
#define digitalPinToPCMSK(p)    ( (((p) >= 6) && ((p) <= 13)) ? (&PCMSK0) : ((std::uint8_t *)0) )
#define digitalPinToPCMSKbit(p) ( (((p) >= 6) && ((p) <= 13)) ? ((p) - 6) : 0 )


#define analogPinToChannel(P)  ( ( ino_mux[(P)] ) )

#if (2 + 2 == 4)

// these arrays map port names (e.g. port B) to the
// appropriate addresses for various functions (e.g. reading
// and writing)







constexpr std::uint8_t ino_port_num[] = {
    4, // 42 - D0  - RX1
    4, // 43 - D1  - TX1

    2, // 22 - D2  - MOSI 
    2, // 27 - D3  -

    4, // 47 - D4  -

    2, // 26 - D5  -
    2, // 25 - D6  -

    4, // 46 - D7  -
    4, // 45 - D8  -
    4, // 44 - D9  -

    2, // 20 - D10 - SS
    2, // 24 - D11 -
    2, // 23 - D12 - MISO
    2, // 21 - D13 - LED13  -  SCK

    4, // 40 - D14 - SCL
    4, // 41 - D15 - SDA

    5, // 57 - D16 - SW_N
    5, // 56 - D17 - SW_E
    5, // 55 - D18 - SW_S
    5, // 54 - D19 - SW_W
    5, // 53 - D20 - LCD_BL
    5, // 52 - D21 - LCD_E
    5, // 51 - D22 - LCD_RW
    5, // 50 - D23 - LCD_RS

    6, // 67 - D24 - A0
    6, // 66 - D25 - A1
    6, // 65 - D26 - A2
    6, // 64 - D27 - A3
    6, // 63 - D28 - A4
    6, // 62 - D29 - A5
    6, // 61 - D30 - A6
    6, // 60 - D31 - A7

    1, // 10 - D32 - LED0   - LCD_DB0
    1, // 11 - D33 - LED1   - LCD_DB1
    1, // 12 - D34 - LED2   - LCD_DB2
    1, // 13 - D35 - LED3   - LCD_DB3
    1, // 14 - D36 - LED4   - LCD_DB4
    1, // 15 - D37 - LED5   - LCD_DB5
    1, // 16 - D38 - LED6   - LCD_DB6
    1, // 17 - D39 - LED7   - LCD_DB7

    3, // 30 - D40 - SERVO_1
    3, // 31 - D41 - SERVO_2
    3, // 32 - D42 - 4A
    3, // 33 - D43 - 2A
    3, // 34 - D44 - 3A
    3, // 35 - D45 - 1A
    3, // 36 - D46 - BUZZER
    3, // 37 - D47 - SW_C

};

constexpr std::uint8_t ino_pin_num[] = {
    2, // PD2 - D0  - RX1
    3, // PD3 - D1  - TX1

    2, // PB2 - D2  - MOSI
    7, // PB7 - D3  -

    7, // PD7 - D4  -

    6, // PB6 - D5  -
    5, // PB5 - D6  -

    6, // PD6 - D7  -
    5, // PD5 - D8  -
    4, // PD4 - D9  -

    0, // PB0 - D10 - SS
    4, // PB4 - D11 -
    3, // PB3 - D12 - MISO
    1, // PB1 - D13 - LED13  -  SCK

    0, // PD0 - D14 - SCL
    1, // PD1 - D15 - SDA

    7, // PE7 - D16 - SW_N
    6, // PE6 - D17 - SW_E
    5, // PE5 - D18 - SW_S
    4, // PE4 - D19 - SW_W
    3, // PE3 - D20 - LCD_BL
    2, // PE2 - D21 - LCD_E
    1, // PE1 - D22 - LCD_RW
    0, // PE0 - D23 - LCD_RS

    7, // PF7 - D24 - A0
    6, // PF6 - D25 - A1
    5, // PF5 - D26 - A2
    4, // PF4 - D27 - A3
    3, // PF3 - D28 - A4
    2, // PF2 - D29 - A5
    1, // PF1 - D30 - A6
    0, // PF0 - D31 - A7

    0, // PA0 - D32 - LED0   - LCD_DB0
    1, // PA1 - D33 - LED1   - LCD_DB1
    2, // PA2 - D34 - LED2   - LCD_DB2
    3, // PA3 - D35 - LED3   - LCD_DB3
    4, // PA4 - D36 - LED4   - LCD_DB4
    5, // PA5 - D37 - LED5   - LCD_DB5
    6, // PA6 - D38 - LED6   - LCD_DB6
    7, // PA7 - D39 - LED7   - LCD_DB7

    0, // PC0 - D40 - SERVO_1
    1, // PC1 - D41 - SERVO_2
    2, // PC2 - D42 - 4A
    3, // PC3 - D43 - 2A
    4, // PC4 - D44 - 3A
    5, // PC5 - D45 - 1A
    6, // PC6 - D46 - BUZZER
    7, // PC7 - D47 - SW_C

};

constexpr std::uint8_t ino_timer_oc_num[] = {
    0, // PD2 - D0  - RX1
    0, // PD3 - D1  - TX1

    0, // PB2 - D2  - MOSI 
    (1 * 3 + 2),      // PB7 - D3  -

    0, // PD7 - D4  -

    (1 * 3 + 1),      // PB6 - D5  -
    (1 * 3 + 0),      // PB5 - D6  -

    0, // PD6 - D7  -
    0, // PD5 - D8  -
    0, // PD4 - D9  -

    0, // PB0 - D10 - SS
    (2 * 3 + 0),      // PB4 - D11 -
    0, // PB3 - D12 - MISO
    0, // PB1 - D13 - LED13  -  SCK

    (0 * 3 + 1),      // PD0 - D14 - SCL
    (2 * 3 + 1),      // PD1 - D15 - SDA

    0, // PE7 - D16 - SW_N
    0, // PE6 - D17 - SW_E
    0, // PE5 - D18 - SW_S
    0, // PE4 - D19 - SW_W
    0, // PE3 - D20 - LCD_BL
    0, // PE2 - D21 - LCD_E
    0, // PE1 - D22 - LCD_RW
    0, // PE0 - D23 - LCD_RS

    0, // PF7 - D24 - A0
    0, // PF6 - D25 - A1
    0, // PF5 - D26 - A2
    0, // PF4 - D27 - A3
    0, // PF3 - D28 - A4
    0, // PF2 - D29 - A5
    0, // PF1 - D30 - A6
    0, // PF0 - D31 - A7

    0, // PA0 - D32 - LED0   - LCD_DB0
    0, // PA1 - D33 - LED1   - LCD_DB1
    0, // PA2 - D34 - LED2   - LCD_DB2
    0, // PA3 - D35 - LED3   - LCD_DB3
    0, // PA4 - D36 - LED4   - LCD_DB4
    0, // PA5 - D37 - LED5   - LCD_DB5
    0, // PA6 - D38 - LED6   - LCD_DB6
    0, // PA7 - D39 - LED7   - LCD_DB7

    0, // PC0 - D40 - SERVO_1
    0, // PC1 - D41 - SERVO_2
    0, // PC2 - D42 - 4A
    0, // PC3 - D43 - 2A
    (3 * 3 + 2), // PC4 - D44 - 3A
    (3 * 3 + 1), // PC5 - D45 - 1A
    (3 * 3 + 0), // PC6 - D46 - BUZZER
    0, // PC7 - D47 - SW_C

};

// Converts pinNumber to MUX channel bits (MUX4..0 datasheet p322)
// First 48 definitions map digital IO pins to ADC channel: digital pins without ADC channel will be read as ground (MUX = 31),
// last defintions can be used for special ADC commamds (like internal bandgap or differential ADC)
constexpr std::uint8_t ino_mux[] = {
    7, // readAnalog(0) => ADC7 (first 7 idices are not digital ports but number of analog channel)
    6, // readAnalog(1) => ADC6 
    5, // readAnalog(2) => ADC5 
    4, // readAnalog(3) => ADC4  
    3, // readAnalog(4) => ADC3 
    2, // readAnalog(5) => ADC2 
    1, // readAnalog(6) => ADC1 
    0, // readAnalog(7) => ADC0

    31, // PD5 - D8: readAnalog(8) => read as ground
    31, // PD4 - D9  -
    31, // PB0 - D10 - SS
    31, // PB4 - D11 -
    31, // PB3 - D12 - MISO
    31, // PB1 - D13 - LED13  -  SCK
    31, // PD0 - D14 - SCL
    31, // PD1 - D15 - SDA

    31, // PE7 - D16 - SW_N
    31, // PE6 - D17 - SW_E
    31, // PE5 - D18 - SW_S
    31, // PE4 - D19 - SW_W
    31, // PE3 - D20 - LCD_BL
    31, // PE2 - D21 - LCD_E
    31, // PE1 - D22 - LCD_RW
    31, // PE0 - D23 - LCD_RS

    7, // PF7 - D24 - A0: readAnalog(A0) => ADC7
    6, // PF6 - D25 - A1: readAnalog(A1) => ADC6
    5, // PF5 - D26 - A2: readAnalog(A2) => ADC5
    4, // PF4 - D27 - A3: readAnalog(A3) => ADC4
    3, // PF3 - D28 - A4: readAnalog(A4) => ADC3
    2, // PF2 - D29 - A5: readAnalog(A5) => ADC2
    1, // PF1 - D30 - A6: readAnalog(A6) => ADC1
    0, // PF0 - D31 - A7: readAnalog(A7) => ADC0

    31, // PA0 - D32 - LED0   - LCD_DB0
    31, // PA1 - D33 - LED1   - LCD_DB1
    31, // PA2 - D34 - LED2   - LCD_DB2
    31, // PA3 - D35 - LED3   - LCD_DB3
    31, // PA4 - D36 - LED4   - LCD_DB4
    31, // PA5 - D37 - LED5   - LCD_DB5
    31, // PA6 - D38 - LED6   - LCD_DB6
    31, // PA7 - D39 - LED7   - LCD_DB7

    31, // PC0 - D40 - SERVO_1
    31, // PC1 - D41 - SERVO_2
    31, // PC2 - D42 - 4A
    31, // PC3 - D43 - 2A
    31, // PC4 - D44 - 3A
    31, // PC5 - D45 - 1A
    31, // PC6 - D46 - BUZZER
    31, // PC7 - D47 - SW_C

    8, // array idx = 48: readAnalog(48) => (ADC0 / ADC0 / 10x)
    9, 
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30, // array idx = 70: readAnalog(BAND_GAP) => Band gap 1.1V
    31  // array idx = 71: readAnalog(GROUND)  => Ground 0V
};

#endif /* ARDUINO_MAIN */

// These serial port names are intended to allow libraries and architecture-neutral
// sketches to automatically default to the correct port name for a particular type
// of use.  For example, a GPS module would normally connect to SERIAL_PORT_HARDWARE_OPEN,
// the first hardware serial port whose RX/TX pins are not dedicated to another use.
//
// SERIAL_PORT_MONITOR        Port which normally prints to the Arduino Serial Monitor
//
// SERIAL_PORT_USBVIRTUAL     Port which is USB virtual serial
//
// SERIAL_PORT_LINUXBRIDGE    Port which connects to a Linux system via Bridge library
//
// SERIAL_PORT_HARDWARE       Hardware serial port, physical RX & TX pins.
//
// SERIAL_PORT_HARDWARE_OPEN  Hardware serial ports which are open for use.  Their RX & TX
//                            pins are NOT connected to anything by default.
#define SERIAL_PORT_MONITOR        Serial
#define SERIAL_PORT_USBVIRTUAL     Serial
#define SERIAL_PORT_HARDWARE       Serial1
#define SERIAL_PORT_HARDWARE_OPEN  Serial1

#endif /* FH_PINS_FASTDUINO_H_ */
