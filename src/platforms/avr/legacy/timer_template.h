// Timer template
// Replace @ to timer num

#ifndef AVR_TIMER@_H_
#define AVR_TIMER@_H_
#define FH_TIMER@#if defined(TCNT@) && (!defined(FH_TIMER1) || (defined(TCCR1A) && defined(TCCR1B)))
#include "../../utils/functions.h"
#include "timer.h"
#include "interrupts.h"

namespace fasthal{	
	// Clock Source	#if defined(FH_TIMER0)		#if !defined(__AVR_ATmega128__)	#define FH_TIMER@_CS_EXT	#endif		#elif defined(FH_TIMER1)		#define FH_TIMER@_CS_EXT		#elif defined(FH_TIMER2)	#if defined(__AVR_ATmega128__)	#define FH_TIMER@_CS_EXT	#endif	#endif		#ifdef FH_TIMER@_CS_EXT	enum class Timer@Cs: uint8_t{
		None    = (0 << CS@2) | (0 << CS@1) | (0 << CS@0),		P0      = (0 << CS@2) | (0 << CS@1) | (1 << CS@0),		P8      = (0 << CS@2) | (1 << CS@1) | (0 << CS@0),		P64     = (0 << CS@2) | (1 << CS@1) | (1 << CS@0),		P256    = (1 << CS@2) | (0 << CS@1) | (0 << CS@0),		P1024   = (1 << CS@2) | (0 << CS@1) | (1 << CS@0),		ExtFall = (1 << CS@2) | (1 << CS@1) | (0 << CS@0),		ExtRise = (1 << CS@2) | (1 << CS@1) | (1 << CS@0)
	};
	#else	enum class Timer@Cs: uint8_t{
		None    = (0 << CS@2) | (0 << CS@1) | (0 << CS@0),		P0      = (0 << CS@2) | (0 << CS@1) | (1 << CS@0),		P8      = (0 << CS@2) | (1 << CS@1) | (0 << CS@0),		P32     = (0 << CS@2) | (1 << CS@1) | (1 << CS@0),		P64     = (1 << CS@2) | (0 << CS@1) | (0 << CS@0),		P128    = (1 << CS@2) | (0 << CS@1) | (1 << CS@0),		P256    = (1 << CS@2) | (1 << CS@1) | (0 << CS@0),		P1024   = (1 << CS@2) | (1 << CS@1) | (1 << CS@0)
	};
	#endif	const uint8_t Timer@CsMask = (1 << CS@2) | (1 << CS@1) | (1 << CS@0);				// Waveform generation mode	#if defined(WGM@0) && defined(WGM@1)	#if defined(WGM@3)	enum class Timer@Wgm: uint8_t{		Normal     = (0 << WGM@3) | (0 << WGM@2) | (0 << WGM@1) | (0 << WGM@0),		PwmPc8     = (0 << WGM@3) | (0 << WGM@2) | (0 << WGM@1) | (1 << WGM@0),		PwmPc9     = (0 << WGM@3) | (0 << WGM@2) | (1 << WGM@1) | (0 << WGM@0),		PwmPc10    = (0 << WGM@3) | (0 << WGM@2) | (1 << WGM@1) | (1 << WGM@0),		CtcA       = (0 << WGM@3) | (1 << WGM@2) | (0 << WGM@1) | (0 << WGM@0),		PwmFast8   = (0 << WGM@3) | (1 << WGM@2) | (0 << WGM@1) | (1 << WGM@0),		PwmFast9   = (0 << WGM@3) | (1 << WGM@2) | (1 << WGM@1) | (0 << WGM@0),		PwmFast10  = (0 << WGM@3) | (1 << WGM@2) | (1 << WGM@1) | (1 << WGM@0),		PwmPcFcI   = (1 << WGM@3) | (0 << WGM@2) | (0 << WGM@1) | (0 << WGM@0),		PwmPcFcA   = (1 << WGM@3) | (0 << WGM@2) | (0 << WGM@1) | (1 << WGM@0),		PwmPcI     = (1 << WGM@3) | (0 << WGM@2) | (1 << WGM@1) | (0 << WGM@0),		PwmPcA     = (1 << WGM@3) | (0 << WGM@2) | (1 << WGM@1) | (1 << WGM@0),		CtcI       = (1 << WGM@3) | (1 << WGM@2) | (0 << WGM@1) | (0 << WGM@0),		//Reserved = (0 << WGM@3) | (1 << WGM@2) | (0 << WGM@1) | (1 << WGM@0),		PwmFastI   = (1 << WGM@3) | (1 << WGM@2) | (1 << WGM@1) | (0 << WGM@0),		PwmFastA   = (1 << WGM@3) | (1 << WGM@2) | (1 << WGM@1) | (1 << WGM@0),	};
	const uint8_t Timer@WgmMask0 = (1 << WGM@1) | (1 << WGM@0);
	const uint8_t Timer@WgmMask1 = (1 << WGM@3) | (1 << WGM@2);	#elif defined(WGM@2)	enum class Timer@Wgm: uint8_t{		Normal     = (0 << WGM@2) | (0 << WGM@1) | (0 << WGM@0),		PwmPcMax   = (0 << WGM@2) | (0 << WGM@1) | (1 << WGM@0),		CtcA       = (0 << WGM@2) | (1 << WGM@1) | (0 << WGM@0),		PwmFastMax = (0 << WGM@2) | (1 << WGM@1) | (1 << WGM@0),
		/*Reserved = (1 << WGM@2) | (0 << WGM@1) | (0 << WGM@0),*/
		PwmPcA     = (1 << WGM@2) | (0 << WGM@1) | (1 << WGM@0),		/*Reserved = (1 << WGM@2) | (1 << WGM@1) | (0 << WGM@0),*/
		PwmFastA   = (1 << WGM@2) | (1 << WGM@1) | (1 << WGM@0)
	};
	const uint8_t Timer@WgmMask0 = (1 << WGM@1) | (1 << WGM@0);
	const uint8_t Timer@WgmMask1 = (1 << WGM@2);	#else	enum class Timer@Wgm: uint8_t{		Normal     = (0 << WGM@1) | (0 << WGM@0),		PwmPcMax   = (0 << WGM@1) | (1 << WGM@0),		CtcA       = (1 << WGM@1) | (0 << WGM@0),		PwmFastMax = (1 < <WGM@1) | (1 << WGM@0)
	};
	const uint8_t Timer@WgmMask = (1 << WGM@1) | (1 << WGM@0);	#endif	#endif		// Compare mode A	#if defined(COM@0) && defined(COM@1)	#define FH_COM@A0 COM@0	#define FH_COM@A1 COM@1	#elif defined(COM@A0) && defined(COM@A1)	#define FH_COM@A0 COM@A0	#define FH_COM@A1 COM@A1	#endif		#if defined(FOC@A)	#define FH_FOC@A FOC@A	#elif defined(FOC@)	#define FH_FOC@A FOC@	#endif	#if defined(FH_COM@A0) && defined(FH_COM@A1)	FH_TIMER_DECLARE_COM_ENUM(Timer@ComA, FH_COM@A0, FH_COM@A1);	#endif		// compare mode B	#if defined(COM@B0) && defined(COM@B1)	FH_TIMER_DECLARE_COM_ENUM(Timer@ComB, COM@B0, COM@B1);	#endif		// compare mode C	#if defined(COM@C0) && defined(COM@C1)	FH_TIMER_DECLARE_COM_ENUM(Timer@ComC, COM@C0, COM@C1);	#endif		// interrupts - enable	enum class Timer@I: uint8_t{		Overflow = (1 << TOIE@)				#if defined(OCIE@A)		, OuputCompareA = (1 << OCIE@A)		#elif defined(OCIE@)		, OuputCompareA = (1 << OCIE@)		#endif				#if defined(OCIE@B)		, OutputCompareB = (1 << OCIE@B)		#endif				#if defined(OCIE@C)		, OutputCompareC = (1 << OCIE@C)		#endif				#if defined(TICIE@)		, InputCapture = (1 << TICIE@)		#endif	};		// interrupts - flag	enum class Timer@F: uint8_t{		Overflow = (1 << TOV@)				#if defined(OCF@A)		, OuputCompareA = (1 << OCF@A)		#elif defined(OCF@)		, OuputCompareA = (1 << OCF@)		#endif				#if defined(OCF@B)		, OuputCompareB = (1 << OCF@B)		#endif		#if defined(OCF@C)		, OuputCompareC = (1 << OCF@C)		#endif				#if defined(ICF@)		, InputCapture = (1 << ICF@)		#endif	};	// wrap registers	namespace priv{		FH_WRAPVARIABLE(TCNTReg@, TCNT@)				#if defined(TCCR)		FH_WRAPVARIABLE(TCCRReg@, TCCR@)				#endif		#if defined(TCCR@A)		FH_WRAPVARIABLE(TCCRAReg@, TCCR@A)		#endif				#if defined(TCCR@B)		FH_WRAPVARIABLE(TCCRBReg@, TCCR@B)		#endif				#if defined(TCCR@C)		FH_WRAPVARIABLE(TCCRCReg@, TCCR@C)		#endif				#if defined(TIMSK@)		FH_WRAPVARIABLE(TIMSKReg@, TIMSK@)		#else		FH_WRAPVARIABLE(TIMSKReg@, TIMSK)		#endif				#if defined(TIFR@)		FH_WRAPVARIABLE(TIFRReg@, TIFR@)		#else		FH_WRAPVARIABLE(TIFRReg@, TIFR)		#endif				#if defined(OCR@A)		FH_WRAPVARIABLE(OCRAReg@, OCR@A)		#elif defined(OCR@)		FH_WRAPVARIABLE(OCRAReg@, OCR@)				#endif				#if defined(OCR@B)		FH_WRAPVARIABLE(OCRBReg@, OCR@B)		#endif				#if defined(OCR@C)		FH_WRAPVARIABLE(OCRCReg@, OCR@C)		#endif				#if defined(ICR@)		FH_WRAPVARIABLE(ICRReg@, ICR@)		#endif				// CS Reg		#if defined(TCCR@B)		typedef TCCRBReg@ TCCRCsReg@;		#else		typedef TCCRReg@ TCCRCsReg@;		#endif				// WGM0/1 Regs		#if defined(WGM@0) && defined(WGM@1)		#if defined(WGM@2)		typedef TCCRAReg@ TCCRWgm0Reg@;		typedef TCCRBReg@ TCCRWgm1Reg@;		#else		typedef TCCRReg@ TCCRWgmReg@;		#endif		#endif				// IC Regs		#if defined(ICNC@) && defined(ICES@)		typedef TCCRBReg@ TCCRIcReg@;		#endif				// COM regs		#if defined(TCCR@A)		typedef TCCRAReg@ TCCRComAReg@;		typedef TCCRAReg@ TCCRComBReg@;		typedef TCCRAReg@ TCCRComCReg@;		#elif defined(TCCR@)		typedef TCCRReg@ TCCRComAReg@;		#endif				// FOC regs		#if defined(TCCR@C)				typedef TCCRCReg@ TCCRFocAReg@;		typedef TCCRCReg@ TCCRFocBReg@;		typedef TCCRCReg@ TCCRFocCReg@;				#elif defined(FH_TIMER0) || defined(FH_TIMER2)		// TCCRB or TCCR		#if defined(TCCR@B)		typedef TCCRBReg@ TCCRFocAReg@;		typedef TCCRBReg@ TCCRFocBReg@;		#elif defined(TCCR@)		typedef TCCRReg@ TCCRFocAReg@;		typedef TCCRReg@ TCCRFocBReg@;		#endif				#elif defined(FH_TIMER1)				// Mega8/32 have it TCCR1A		typedef TCCRAReg@ TCCRFocAReg@;		typedef TCCRAReg@ TCCRFocBReg@;				#endif	}			// The big timer	struct Timer@:		public AvrTimerCS<priv::TCCRCsReg@, Timer@Cs, Timer@CsMask, priv::TCNTReg@>		, public InterruptControl<priv::TIMSKReg@, Timer@I>		, public InterruptFlags<priv::TIFRReg@, Timer@F>				#if defined(WGM@0) && defined(WGM@1)		// has WGM. 		#if defined(WGM@2)		, public AvrTimerWGM2<priv::TCCRWgm0Reg@, priv::TCCRWgm1Reg@, Timer@Wgm, Timer@WgmMask0, Timer@WgmMask1>		#else		, public AvrTimerWGM<priv::TCCRWgmReg@, Timer@Wgm, Timer@WgmMask>		#endif		#endif				#if defined(ICNC@) && defined(ICES@)		, public AvrTimerIc<priv::TCCRIcReg@, ICNC@, ICES@, priv::ICRReg@>		#endif				#if defined(FH_COM@A0) && defined(FH_COM@A1)		// has A		, public AvrTimerOcA<priv::TCCRComAReg@, Timer@ComA, Timer@ComAMask, priv::OCRAReg@>		#endif		#if defined(FH_FOC@A)		// can force A		, public AvrTimerForceOcA<priv::TCCRFocAReg@, FH_FOC@A>		#endif				#if defined(COM@B0) && defined(COM@B1)		// has B		, public AvrTimerOcB<priv::TCCRComBReg@, Timer@ComB, Timer@ComBMask, priv::OCRBReg@>		#endif		#if defined(FOC@B)		// can force B		, public AvrTimerForceOcB<priv::TCCRFocBReg@, FOC@B>		#endif
				#if defined(COM@C0) && defined(COM@C1)		// has C		, public AvrTimerOcC<priv::TCCRComCReg@, Timer@ComC, Timer@ComCMask, priv::OCRCReg@>		#endif		#if defined(FOC@C)		// can force C		, public AvrTimerForceOcC<priv::TCCRFocCReg@, FOC@C>		#endif
	{
	};
}


#endif // defined TCCR

#undef FH_TIMER@

#endif /* TIMER0_H_ */