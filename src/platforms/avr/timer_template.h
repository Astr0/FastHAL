// Timer template
// Replace @ to timer num

#ifndef AVR_TIMER@_H_
#define AVR_TIMER@_H_
#define FH_TIMER@#if defined(TCNT@) && (!defined(FH_TIMER1) || (defined(TCCR1A) && defined(TCCR1B)))
#include "../../utils/functions.h"
#include "timer.h"
#include "interrupts.h"

namespace fasthal{	
	// Clock Source	#if defined(FH_TIMER0)		#if !defined(__AVR_ATmega128__)	#define FH_TIMER@_CS_EXT	#endif		#elif defined(FH_TIMER1)		#define FH_TIMER@_CS_EXT		#elif defined(FH_TIMER2)	#if defined(__AVR_ATmega128__)	#define FH_TIMER@_CS_EXT	#endif	#endif		#ifdef FH_TIMER@_CS_EXT	// CPU Specific	FH_TIMER_DECLARE_CS_ENUM_3_EXT(Timer@Cs, CS@0, CS@1, CS@2);	#else	FH_TIMER_DECLARE_CS_ENUM_3(Timer@Cs, CS@0, CS@1, CS@2);	#endif				// Waveform generation mode	#if defined(WGM@0) && defined(WGM@1)	#if defined(WGM@3)	FH_TIMER_DECLARE_WGM_ENUM_4(Timer@Wgm, WGM@0, WGM@1, WGM@2, WGM@3);	#elif defined(WGM@2)	FH_TIMER_DECLARE_WGM_ENUM_3(Timer@Wgm, WGM@0, WGM@1, WGM@2);	#else	FH_TIMER_DECLARE_WGM_ENUM_2(Timer@Wgm, WGM@0, WGM@1);	#endif	#endif		// Compare mode A	#if defined(COM@0) && defined(COM@1)	#define FH_COM@A0 COM@0	#define FH_COM@A1 COM@1	#elif defined(COM@A0) && defined(COM@A1)	#define FH_COM@A0 COM@A0	#define FH_COM@A1 COM@A1	#endif		#if defined(FOC@A)	#define FH_FOC@A FOC@A	#elif defined(FOC@)	#define FH_FOC@A FOC@	#endif	#if defined(FH_COM@A0) && defined(FH_COM@A1)	FH_TIMER_DECLARE_COM_ENUM(Timer@ComA, FH_COM@A0, FH_COM@A1);	#endif		// compare mode B	#if defined(COM@B0) && defined(COM@B1)	FH_TIMER_DECLARE_COM_ENUM(Timer@ComB, COM@B0, COM@B1);	#endif		// compare mode C	#if defined(COM@C0) && defined(COM@C1)	FH_TIMER_DECLARE_COM_ENUM(Timer@ComC, COM@C0, COM@C1);	#endif		// interrupts - enable	enum class Timer@I: uint8_t{		Overflow = (1 << TOIE@)				#if defined(OCIE@A)		, OuputCompareA = (1 << OCIE@A)		#elif defined(OCIE@)		, OuputCompareA = (1 << OCIE@)		#endif				#if defined(OCIE@B)		, OutputCompareB = (1 << OCIE@B)		#endif				#if defined(OCIE@C)		, OutputCompareC = (1 << OCIE@C)		#endif	};		// interrupts - flag	enum class Timer@F: uint8_t{		Overflow = (1 << TOV@)				#if defined(OCF@A)		, OuputCompareA = (1 << OCF@A)		#elif defined(OCF@)		, OuputCompareA = (1 << OCF@)		#endif				#if defined(OCF@B)		, OuputCompareB = (1 << OCF@B)		#endif		#if defined(OCF@C)		, OuputCompareC = (1 << OCF@C)		#endif	};	// wrap registers	namespace priv{		FH_WRAPVARIABLE(TCNTReg@, TCNT@)				#if defined(TCCR)		FH_WRAPVARIABLE(TCCRReg@, TCCR@)				#endif		#if defined(TCCR@A)		FH_WRAPVARIABLE(TCCRAReg@, TCCR@A)		#endif				#if defined(TCCR@B)		FH_WRAPVARIABLE(TCCRBReg@, TCCR@B)		#endif				#if defined(TCCR@C)		FH_WRAPVARIABLE(TCCRCReg@, TCCR@C)		#endif				#if defined(TIMSK@)		FH_WRAPVARIABLE(TIMSKReg@, TIMSK@)		#else		FH_WRAPVARIABLE(TIMSKReg@, TIMSK)		#endif				#if defined(TIFR@)		FH_WRAPVARIABLE(TIFRReg@, TIFR@)		#else		FH_WRAPVARIABLE(TIFRReg@, TIFR)		#endif				#if defined(OCR@A)		FH_WRAPVARIABLE(OCRAReg@, OCR@A)		#elif defined(OCR@)		FH_WRAPVARIABLE(OCRAReg@, OCR@)				#endif				#if defined(OCR@B)		FH_WRAPVARIABLE(OCRBReg@, OCR@B)		#endif				#if defined(OCR@C)		FH_WRAPVARIABLE(OCRCReg@, OCR@C)		#endif				// CS Reg		#if defined(TCCR@B)		typedef TCCRBReg@ TCCRCsReg@;		#else		typedef TCCRReg@ TCCRCsReg@;		#endif				// WGM0/1 Regs		#if defined(WGM@0) && defined(WGM@1)		#if defined(WGM@2)		typedef TCCRAReg@ TCCRWgm0Reg@;		typedef TCCRBReg@ TCCRWgm1Reg@;		#else		typedef TCCRReg@ TCCRWgmReg@;		#endif		#endif				// COM regs		#if defined(TCCR@A)		typedef TCCRAReg@ TCCRComAReg@;		typedef TCCRAReg@ TCCRComBReg@;		typedef TCCRAReg@ TCCRComCReg@;		#elif defined(TCCR@)		typedef TCCRReg@ TCCRComAReg@;		#endif				// FOC regs		#if defined(TCCR@C)				typedef TCCRCReg@ TCCRFocAReg@;		typedef TCCRCReg@ TCCRFocBReg@;		typedef TCCRCReg@ TCCRFocCReg@;				#elif defined(FH_TIMER0) || defined(FH_TIMER2)		// TCCRB or TCCR		#if defined(TCCR@B)		typedef TCCRBReg@ TCCRFocAReg@;		typedef TCCRBReg@ TCCRFocBReg@;		#elif defined(TCCR@)		typedef TCCRReg@ TCCRFocAReg@;		typedef TCCRReg@ TCCRFocBReg@;		#endif				#elif defined(FH_TIMER1)				// Mega8/32 have it TCCR1A		typedef TCCRAReg@ TCCRFocAReg@;		typedef TCCRAReg@ TCCRFocBReg@;				#endif	}			// The big timer	struct Timer@:		public AvrTimerCS<priv::TCCRCsReg@, Timer@Cs, Timer@CsMask, priv::TCNTReg@>		, public InterruptControl<priv::TIMSKReg@, Timer@I>		, public InterruptFlags<priv::TIFRReg@, Timer@F>				#if defined(WGM@0) && defined(WGM@1)		// has WGM. 		#if defined(WGM@2)		, public AvrTimerWGM2<priv::TCCRWgm0Reg@, priv::TCCRWgm1Reg@, Timer@Wgm, Timer@WgmMask0, Timer@WgmMask1>		#else		, public AvrTimerWGM<priv::TCCRWgmReg@, Timer@Wgm, Timer@WgmMask>		#endif		#endif				#if defined(FH_COM@A0) && defined(FH_COM@A1)		// has A		, public AvrTimerComA<priv::TCCRComAReg@, Timer@ComA, Timer@ComAMask, priv::OCRAReg@>		#endif		#if defined(FH_FOC@A)		// can force A		, public AvrTimerForceA<priv::TCCRFocAReg@, FH_FOC@A>		#endif				#if defined(COM@B0) && defined(COM@B1)		// has B		, public AvrTimerComB<priv::TCCRComBReg@, Timer@ComB, Timer@ComBMask, priv::OCRBReg@>		#endif		#if defined(FOC@B)		// can force B		, public AvrTimerForceB<priv::TCCRFocBReg@, FOC@B>		#endif
				#if defined(COM@C0) && defined(COM@C1)		// has C		, public AvrTimerComC<priv::TCCRComCReg@, Timer@ComC, Timer@ComCMask, priv::OCRCReg@>		#endif		#if defined(FOC@C)		// can force C		, public AvrTimerForceC<priv::TCCRFocCReg@, FOC@C>		#endif
	{
	};
}


#endif // defined TCCR

#undef FH_TIMER@

#endif /* TIMER0_H_ */